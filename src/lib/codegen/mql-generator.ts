import { Node, Edge } from '@xyflow/react'
import { Strategy } from '@/types/strategy'

export interface MQLGeneratorOptions {
  language: 'mql4' | 'mql5'
  strategyName: string
  includeComments: boolean
  optimizeCode: boolean
}

export interface GeneratedCode {
  source: string
  filename: string
  language: 'mql4' | 'mql5'
  warnings: string[]
  errors: string[]
}

export class MQLCodeGenerator {
  private nodes: Node[]
  private edges: Edge[]
  private options: MQLGeneratorOptions
  private warnings: string[] = []
  private errors: string[] = []
  private indentLevel = 0
  private variableCounter = 0

  constructor(
    strategy: Strategy,
    options: Partial<MQLGeneratorOptions> = {}
  ) {
    this.nodes = strategy.nodes || []
    this.edges = strategy.edges || []
    this.options = {
      language: options.language || 'mql5',
      strategyName: options.strategyName || strategy.name || 'GeneratedEA',
      includeComments: options.includeComments !== false,
      optimizeCode: options.optimizeCode !== false
    }
  }

  generate(): GeneratedCode {
    this.warnings = []
    this.errors = []
    
    const code = this.generateCode()
    
    return {
      source: code,
      filename: `${this.sanitizeFilename(this.options.strategyName)}.${this.options.language === 'mql4' ? 'mq4' : 'mq5'}`,
      language: this.options.language,
      warnings: this.warnings,
      errors: this.errors
    }
  }

  private generateCode(): string {
    const sections: string[] = []

    sections.push(this.generateHeader())
    sections.push(this.generateInputParameters())
    sections.push(this.generateGlobalVariables())
    sections.push(this.generateOnInit())
    sections.push(this.generateOnDeinit())
    sections.push(this.generateOnTick())
    sections.push(this.generateOnTimer())
    sections.push(this.generateHelperFunctions())

    return sections.join('\n\n')
  }

  private generateHeader(): string {
    const lines: string[] = []
    const border = '//+------------------------------------------------------------------+'
    
    lines.push(border)
    lines.push(`//| ${this.options.strategyName.padEnd(64, ' ')} |`)
    lines.push(`//| Generated by ForexFlow Bot Builder                               |`)
    lines.push(`//| ${new Date().toISOString().slice(0, 10).padEnd(64, ' ')} |`)
    lines.push(border)
    
    if (this.options.language === 'mql5') {
      lines.push('#property copyright "Generated by ForexFlow"')
      lines.push('#property link      "https://forexflow.app"')
      lines.push('#property version   "1.00"')
      lines.push('#property strict')
    } else {
      lines.push('//+------------------------------------------------------------------+')
      lines.push('//| Expert initialization function                                   |')
      lines.push('//+------------------------------------------------------------------+')
    }
    
    return lines.join('\n')
  }

  private generateInputParameters(): string {
    const lines: string[] = []
    
    if (this.options.includeComments) {
      lines.push('// Input Parameters')
    }
    
    const inputNodes = this.nodes.filter(n => 
      n.data.label?.toLowerCase().includes('constant') || 
      n.data.isInput
    )

    lines.push('input double LotSize = 0.01;          // Position Size')
    lines.push('input int StopLoss = 50;              // Stop Loss (pips)')
    lines.push('input int TakeProfit = 100;           // Take Profit (pips)')
    lines.push('input int MagicNumber = 12345;        // Magic Number')
    lines.push('input int Slippage = 3;               // Slippage (pips)')
    
    const indicatorNodes = this.nodes.filter(n => n.type === 'indicator')
    indicatorNodes.forEach(node => {
      const label = node.data.label
      const params = node.data
      
      if (label?.includes('MA') || label?.includes('SMA') || label?.includes('EMA')) {
        lines.push(`input int ${this.sanitizeVariableName(label)}_Period = ${params.period || 14};  // ${label} Period`)
      } else if (label?.includes('RSI')) {
        lines.push(`input int RSI_Period = ${params.period || 14};              // RSI Period`)
      } else if (label?.includes('MACD')) {
        lines.push(`input int MACD_Fast = ${params.fastPeriod || 12};          // MACD Fast Period`)
        lines.push(`input int MACD_Slow = ${params.slowPeriod || 26};          // MACD Slow Period`)
        lines.push(`input int MACD_Signal = ${params.signalPeriod || 9};       // MACD Signal Period`)
      }
    })
    
    return lines.join('\n')
  }

  private generateGlobalVariables(): string {
    const lines: string[] = []
    
    if (this.options.includeComments) {
      lines.push('// Global Variables')
    }
    
    lines.push('int ticket = 0;')
    lines.push('double point;')
    lines.push('int digits;')
    
    const variableNodes = this.nodes.filter(n => 
      n.type === 'variable' || n.data.label?.toLowerCase().includes('variable')
    )
    
    variableNodes.forEach(node => {
      const varName = this.sanitizeVariableName(node.data.label || `var_${node.id}`)
      const varType = node.data.variableType || 'double'
      lines.push(`${this.mapDataType(varType)} ${varName};`)
    })
    
    return lines.join('\n')
  }

  private generateOnInit(): string {
    const lines: string[] = []
    
    lines.push('int OnInit()')
    lines.push('{')
    this.indentLevel++
    
    if (this.options.includeComments) {
      lines.push(this.indent('// Initialize EA'))
    }
    
    lines.push(this.indent('point = _Point;'))
    lines.push(this.indent('digits = _Digits;'))
    lines.push(this.indent(`Print("${this.options.strategyName} initialized successfully");`))
    
    const initNodes = this.nodes.filter(n => 
      n.type === 'event' && n.data.eventType === 'init'
    )
    
    if (initNodes.length > 0) {
      lines.push(this.indent(''))
      lines.push(this.indent('// Custom initialization logic'))
      initNodes.forEach(node => {
        const code = this.generateNodeLogic(node)
        if (code) lines.push(this.indent(code))
      })
    }
    
    lines.push(this.indent('return(INIT_SUCCEEDED);'))
    
    this.indentLevel--
    lines.push('}')
    
    return lines.join('\n')
  }

  private generateOnDeinit(): string {
    const lines: string[] = []
    
    lines.push('void OnDeinit(const int reason)')
    lines.push('{')
    this.indentLevel++
    
    if (this.options.includeComments) {
      lines.push(this.indent('// Cleanup on EA removal'))
    }
    
    lines.push(this.indent(`Print("${this.options.strategyName} stopped");`))
    
    const deinitNodes = this.nodes.filter(n => 
      n.type === 'event' && n.data.eventType === 'deinit'
    )
    
    if (deinitNodes.length > 0) {
      deinitNodes.forEach(node => {
        const code = this.generateNodeLogic(node)
        if (code) lines.push(this.indent(code))
      })
    }
    
    this.indentLevel--
    lines.push('}')
    
    return lines.join('\n')
  }

  private generateOnTick(): string {
    const lines: string[] = []
    
    lines.push('void OnTick()')
    lines.push('{')
    this.indentLevel++
    
    if (this.options.includeComments) {
      lines.push(this.indent('// Main trading logic - executed on every tick'))
    }
    
    const tickNodes = this.findRootNodes('ontick')
    
    if (tickNodes.length === 0) {
      this.warnings.push('No OnTick logic nodes found. EA will not execute any trading logic.')
      lines.push(this.indent('// No trading logic defined'))
    } else {
      lines.push(this.indent('// Get indicator values'))
      const indicatorCode = this.generateIndicatorCalculations()
      if (indicatorCode) {
        lines.push(this.indent(indicatorCode))
      }
      
      lines.push(this.indent(''))
      lines.push(this.indent('// Evaluate trading conditions'))
      const conditionCode = this.generateConditionChecks(tickNodes)
      lines.push(this.indent(conditionCode))
    }
    
    this.indentLevel--
    lines.push('}')
    
    return lines.join('\n')
  }

  private generateOnTimer(): string {
    const timerNodes = this.findRootNodes('ontimer')
    
    if (timerNodes.length === 0) {
      return ''
    }
    
    const lines: string[] = []
    
    lines.push('void OnTimer()')
    lines.push('{')
    this.indentLevel++
    
    if (this.options.includeComments) {
      lines.push(this.indent('// Timer-based logic'))
    }
    
    timerNodes.forEach(node => {
      const code = this.generateNodeLogic(node)
      if (code) lines.push(this.indent(code))
    })
    
    this.indentLevel--
    lines.push('}')
    
    return lines.join('\n')
  }

  private generateIndicatorCalculations(): string {
    const lines: string[] = []
    const indicatorNodes = this.nodes.filter(n => n.type === 'indicator')
    
    indicatorNodes.forEach(node => {
      const label = node.data.label
      const params = node.data
      
      if (label?.includes('MA') || label?.includes('SMA')) {
        lines.push(`double ${this.sanitizeVariableName(label)} = iMA(_Symbol, PERIOD_CURRENT, ${params.period || 14}, 0, MODE_SMA, PRICE_CLOSE, 0);`)
      } else if (label?.includes('EMA')) {
        lines.push(`double ${this.sanitizeVariableName(label)} = iMA(_Symbol, PERIOD_CURRENT, ${params.period || 14}, 0, MODE_EMA, PRICE_CLOSE, 0);`)
      } else if (label?.includes('RSI')) {
        lines.push(`double RSI_Value = iRSI(_Symbol, PERIOD_CURRENT, ${params.period || 14}, PRICE_CLOSE, 0);`)
      } else if (label?.includes('MACD')) {
        lines.push(`double MACD_Main = iMACD(_Symbol, PERIOD_CURRENT, ${params.fastPeriod || 12}, ${params.slowPeriod || 26}, ${params.signalPeriod || 9}, PRICE_CLOSE, MODE_MAIN, 0);`)
        lines.push(`double MACD_Signal = iMACD(_Symbol, PERIOD_CURRENT, ${params.fastPeriod || 12}, ${params.slowPeriod || 26}, ${params.signalPeriod || 9}, PRICE_CLOSE, MODE_SIGNAL, 0);`)
      } else if (label?.includes('Bollinger') || label?.includes('BB')) {
        lines.push(`double BB_Upper = iBands(_Symbol, PERIOD_CURRENT, ${params.period || 20}, ${params.deviation || 2}, 0, PRICE_CLOSE, MODE_UPPER, 0);`)
        lines.push(`double BB_Lower = iBands(_Symbol, PERIOD_CURRENT, ${params.period || 20}, ${params.deviation || 2}, 0, PRICE_CLOSE, MODE_LOWER, 0);`)
        lines.push(`double BB_Middle = iBands(_Symbol, PERIOD_CURRENT, ${params.period || 20}, ${params.deviation || 2}, 0, PRICE_CLOSE, MODE_MAIN, 0);`)
      } else if (label?.includes('ATR')) {
        lines.push(`double ATR_Value = iATR(_Symbol, PERIOD_CURRENT, ${params.period || 14}, 0);`)
      }
    })
    
    return lines.join('\n')
  }

  private generateConditionChecks(rootNodes: Node[]): string {
    const lines: string[] = []
    
    rootNodes.forEach(rootNode => {
      const chain = this.buildExecutionChain(rootNode)
      const code = this.generateChainCode(chain)
      lines.push(code)
    })
    
    return lines.join('\n')
  }

  private buildExecutionChain(startNode: Node): Node[] {
    const chain: Node[] = [startNode]
    const visited = new Set<string>([startNode.id])
    
    const findNext = (currentId: string): Node | null => {
      const edge = this.edges.find(e => e.source === currentId)
      if (!edge) return null
      
      const nextNode = this.nodes.find(n => n.id === edge.target)
      if (!nextNode || visited.has(nextNode.id)) return null
      
      visited.add(nextNode.id)
      return nextNode
    }
    
    let current = startNode
    while (true) {
      const next = findNext(current.id)
      if (!next) break
      chain.push(next)
      current = next
    }
    
    return chain
  }

  private generateChainCode(chain: Node[]): string {
    const lines: string[] = []
    let currentIndent = 0
    
    for (let i = 0; i < chain.length; i++) {
      const node = chain[i]
      const nodeCode = this.generateNodeLogic(node, currentIndent)
      
      if (nodeCode) {
        if (node.type === 'condition' || node.type === 'logic') {
          lines.push(nodeCode)
          lines.push(this.indent('{', currentIndent))
          currentIndent++
        } else if (node.type === 'action') {
          lines.push(this.indent(nodeCode, currentIndent))
        } else {
          lines.push(this.indent(nodeCode, currentIndent))
        }
      }
    }
    
    while (currentIndent > 0) {
      currentIndent--
      lines.push(this.indent('}', currentIndent))
    }
    
    return lines.join('\n')
  }

  private generateNodeLogic(node: Node, indentOffset = 0): string {
    const type = node.type
    const data = node.data
    
    switch (type) {
      case 'condition':
        return this.generateConditionCode(node)
      
      case 'logic':
        return this.generateLogicCode(node)
      
      case 'action':
        return this.generateActionCode(node)
      
      case 'indicator':
        return ''
      
      default:
        return `// ${data.label || 'Unknown node'}`
    }
  }

  private generateConditionCode(node: Node): string {
    const data = node.data
    const comparison = data.comparison || '>'
    const threshold = data.threshold || 0
    
    if (data.label?.includes('RSI')) {
      return `if (RSI_Value ${comparison} ${threshold})`
    } else if (data.label?.includes('Cross')) {
      return `if (CrossOver)`
    } else {
      return `if (Condition_${node.id})`
    }
  }

  private generateLogicCode(node: Node): string {
    const data = node.data
    const operation = data.operation?.toUpperCase() || 'AND'
    
    return `${operation}`
  }

  private generateActionCode(node: Node): string {
    const data = node.data
    const label = data.label?.toLowerCase() || ''
    
    if (label.includes('buy')) {
      return this.generateBuyOrder()
    } else if (label.includes('sell')) {
      return this.generateSellOrder()
    } else if (label.includes('close')) {
      return this.generateCloseOrder()
    } else if (label.includes('alert')) {
      return `Alert("${data.message || 'Trading Alert'}");`
    } else {
      return `// Action: ${data.label}`
    }
  }

  private generateBuyOrder(): string {
    if (this.options.language === 'mql5') {
      return `
MqlTradeRequest request = {};
MqlTradeResult result = {};
request.action = TRADE_ACTION_DEAL;
request.symbol = _Symbol;
request.volume = LotSize;
request.type = ORDER_TYPE_BUY;
request.price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
request.sl = request.price - StopLoss * _Point;
request.tp = request.price + TakeProfit * _Point;
request.deviation = Slippage;
request.magic = MagicNumber;
request.comment = "${this.options.strategyName}";
OrderSend(request, result);
Print("Buy order placed: ", result.order);`
    } else {
      return `ticket = OrderSend(_Symbol, OP_BUY, LotSize, Ask, Slippage, Ask - StopLoss * _Point, Ask + TakeProfit * _Point, "${this.options.strategyName}", MagicNumber, 0, clrGreen);`
    }
  }

  private generateSellOrder(): string {
    if (this.options.language === 'mql5') {
      return `
MqlTradeRequest request = {};
MqlTradeResult result = {};
request.action = TRADE_ACTION_DEAL;
request.symbol = _Symbol;
request.volume = LotSize;
request.type = ORDER_TYPE_SELL;
request.price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
request.sl = request.price + StopLoss * _Point;
request.tp = request.price - TakeProfit * _Point;
request.deviation = Slippage;
request.magic = MagicNumber;
request.comment = "${this.options.strategyName}";
OrderSend(request, result);
Print("Sell order placed: ", result.order);`
    } else {
      return `ticket = OrderSend(_Symbol, OP_SELL, LotSize, Bid, Slippage, Bid + StopLoss * _Point, Bid - TakeProfit * _Point, "${this.options.strategyName}", MagicNumber, 0, clrRed);`
    }
  }

  private generateCloseOrder(): string {
    if (this.options.language === 'mql5') {
      return `
for(int i = PositionsTotal() - 1; i >= 0; i--)
{
   if(PositionSelectByTicket(PositionGetTicket(i)))
   {
      if(PositionGetInteger(POSITION_MAGIC) == MagicNumber)
      {
         MqlTradeRequest request = {};
         MqlTradeResult result = {};
         request.action = TRADE_ACTION_DEAL;
         request.position = PositionGetTicket(i);
         request.symbol = _Symbol;
         request.volume = PositionGetDouble(POSITION_VOLUME);
         request.type = (ENUM_ORDER_TYPE)(1 - PositionGetInteger(POSITION_TYPE));
         request.price = (PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK);
         request.deviation = Slippage;
         request.magic = MagicNumber;
         OrderSend(request, result);
      }
   }
}`
    } else {
      return `
for(int i = OrdersTotal() - 1; i >= 0; i--)
{
   if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
   {
      if(OrderMagicNumber() == MagicNumber && OrderSymbol() == _Symbol)
      {
         OrderClose(OrderTicket(), OrderLots(), OrderClosePrice(), Slippage, clrWhite);
      }
   }
}`
    }
  }

  private generateHelperFunctions(): string {
    const lines: string[] = []
    
    if (this.options.includeComments) {
      lines.push('// Helper Functions')
    }
    
    return lines.join('\n')
  }

  private findRootNodes(eventType: string): Node[] {
    return this.nodes.filter(node => {
      if (node.type === 'event' && node.data.eventType === eventType) {
        return true
      }
      
      const hasIncomingEdge = this.edges.some(e => e.target === node.id)
      if (hasIncomingEdge) return false
      
      return true
    })
  }

  private indent(text: string, extraLevel = 0): string {
    const spaces = '   '
    const totalLevel = this.indentLevel + extraLevel
    return spaces.repeat(totalLevel) + text
  }

  private sanitizeFilename(name: string): string {
    return name.replace(/[^a-zA-Z0-9_-]/g, '_')
  }

  private sanitizeVariableName(name: string): string {
    let varName = name.replace(/[^a-zA-Z0-9_]/g, '_')
    if (/^\d/.test(varName)) {
      varName = '_' + varName
    }
    return varName
  }

  private mapDataType(type: string): string {
    const typeMap: Record<string, string> = {
      'number': 'double',
      'integer': 'int',
      'boolean': 'bool',
      'string': 'string',
      'double': 'double',
      'int': 'int',
      'bool': 'bool'
    }
    
    return typeMap[type.toLowerCase()] || 'double'
  }
}
