import { Strategy, StrategyNode } from '@/types/strategy'
import { Node, Edge } from '@xyflow/react'

export type MQLVersion = 'mql4' | 'mql5'

export interface MQLExportOptions {
  version: MQLVersion
  expertName: string
  magicNumber: number
  description?: string
  author?: string
}

export interface GraphAnalysis {
  eventNodes: StrategyNode[]
  indicators: StrategyNode[]
  conditions: StrategyNode[]
  logic: StrategyNode[]
  actions: StrategyNode[]
  risk: StrategyNode[]
  advanced: StrategyNode[]
  variables: StrategyNode[]
  mtf: StrategyNode[]
  patterns: StrategyNode[]
  executionPaths: Map<string, StrategyNode[]>
}

export function exportToMQL(strategy: Strategy, options: MQLExportOptions): string {
  const analysis = analyzeStrategyGraph(strategy)
  
  if (options.version === 'mql4') {
    return generateMQL4(strategy, options, analysis)
  } else {
    return generateMQL5(strategy, options, analysis)
  }
}

function analyzeStrategyGraph(strategy: Strategy): GraphAnalysis {
  const nodes = strategy.nodes || []
  const edges = strategy.edges || []
  
  const eventNodes = nodes.filter(n => (n.data as any).category === 'event')
  const indicators = nodes.filter(n => (n.data as any).category === 'indicator')
  const conditions = nodes.filter(n => (n.data as any).category === 'condition')
  const logic = nodes.filter(n => (n.data as any).category === 'logic')
  const actions = nodes.filter(n => (n.data as any).category === 'action')
  const risk = nodes.filter(n => (n.data as any).category === 'risk')
  const advanced = nodes.filter(n => (n.data as any).category === 'advanced')
  const variables = nodes.filter(n => (n.data as any).category === 'variable')
  const mtf = nodes.filter(n => (n.data as any).category === 'mtf')
  const patterns = nodes.filter(n => (n.data as any).category === 'pattern')
  
  const executionPaths = new Map<string, StrategyNode[]>()
  
  eventNodes.forEach(eventNode => {
    const path = traverseExecutionPath(eventNode, nodes, edges)
    executionPaths.set(eventNode.id, path)
  })
  
  return {
    eventNodes,
    indicators,
    conditions,
    logic,
    actions,
    risk,
    advanced,
    variables,
    mtf,
    patterns,
    executionPaths
  }
}

function traverseExecutionPath(
  startNode: StrategyNode,
  allNodes: StrategyNode[],
  edges: Edge[]
): StrategyNode[] {
  const visited = new Set<string>()
  const path: StrategyNode[] = []
  
  function traverse(nodeId: string) {
    if (visited.has(nodeId)) return
    visited.add(nodeId)
    
    const node = allNodes.find(n => n.id === nodeId)
    if (!node) return
    
    path.push(node)
    
    const outgoingEdges = edges.filter(e => e.source === nodeId)
    outgoingEdges.forEach(edge => traverse(edge.target))
  }
  
  traverse(startNode.id)
  return path
}

function generateMQL4(
  strategy: Strategy,
  options: MQLExportOptions,
  analysis: GraphAnalysis
): string {
  const { expertName, magicNumber, description, author } = options
  
  return `//+------------------------------------------------------------------+
//|                                              ${expertName}.mq4 |
//|                        Generated by ForexFlow Visual Bot Builder |
//|                                      ${author || 'ForexFlow User'} |
//+------------------------------------------------------------------+
#property copyright "${author || 'Generated by ForexFlow'}"
#property link      "https://github.com/forexflow"
#property version   "1.00"
#property description "${description || 'Expert Advisor generated from visual strategy'}"
#property strict

//+------------------------------------------------------------------+
//| Input Parameters                                                 |
//+------------------------------------------------------------------+
input group "=== Expert Settings ==="
input int    MagicNumber = ${magicNumber};
input string ExpertComment = "${expertName}";

input group "=== Trading Settings ==="
input double LotSize = 0.01;
input int    Slippage = 3;
input int    MaxOpenTrades = 1;

${generateMQL4IndicatorInputs(analysis.indicators)}

${generateMQL4RiskInputs(analysis.risk)}

${generateMQL4AdvancedInputs(analysis.advanced)}

//+------------------------------------------------------------------+
//| Global Variables                                                  |
//+------------------------------------------------------------------+
${generateMQL4GlobalVariables(analysis)}

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
${generateMQL4OnInitLogic(analysis)}
   
   Print("${expertName} initialized successfully");
   Print("Magic Number: ", MagicNumber);
   
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
${generateMQL4OnDeinitLogic(analysis)}
   
   Print("${expertName} deinitialized. Reason: ", reason);
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
${generateMQL4OnTickLogic(analysis)}
}

${generateMQL4OnTimerLogic(analysis)}

${generateMQL4OnTradeLogic(analysis)}

${generateMQL4HelperFunctions(analysis)}

${generateMQL4IndicatorFunctions(analysis.indicators)}

${generateMQL4ConditionFunctions(analysis.conditions)}

${generateMQL4TradeManagementFunctions(analysis.advanced)}

//+------------------------------------------------------------------+`
}

function generateMQL5(
  strategy: Strategy,
  options: MQLExportOptions,
  analysis: GraphAnalysis
): string {
  const { expertName, magicNumber, description, author } = options
  
  return `//+------------------------------------------------------------------+
//|                                              ${expertName}.mq5 |
//|                        Generated by ForexFlow Visual Bot Builder |
//|                                      ${author || 'ForexFlow User'} |
//+------------------------------------------------------------------+
#property copyright "${author || 'Generated by ForexFlow'}"
#property link      "https://github.com/forexflow"
#property version   "1.00"
#property description "${description || 'Expert Advisor generated from visual strategy'}"

#include <Trade\\Trade.mqh>

//+------------------------------------------------------------------+
//| Input Parameters                                                 |
//+------------------------------------------------------------------+
input group "=== Expert Settings ==="
input int    MagicNumber = ${magicNumber};
input string ExpertComment = "${expertName}";

input group "=== Trading Settings ==="
input double LotSize = 0.01;
input int    Slippage = 3;
input int    MaxOpenTrades = 1;

${generateMQL5IndicatorInputs(analysis.indicators)}

${generateMQL5RiskInputs(analysis.risk)}

${generateMQL5AdvancedInputs(analysis.advanced)}

//+------------------------------------------------------------------+
//| Global Variables                                                  |
//+------------------------------------------------------------------+
CTrade trade;
${generateMQL5GlobalVariables(analysis)}

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   trade.SetExpertMagicNumber(MagicNumber);
   trade.SetDeviationInPoints(Slippage);
   trade.SetTypeFilling(ORDER_FILLING_FOK);
   
${generateMQL5OnInitLogic(analysis)}
   
   Print("${expertName} initialized successfully");
   Print("Magic Number: ", MagicNumber);
   
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
${generateMQL5OnDeinitLogic(analysis)}
   
   Print("${expertName} deinitialized. Reason: ", reason);
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
${generateMQL5OnTickLogic(analysis)}
}

${generateMQL5OnTimerLogic(analysis)}

${generateMQL5OnTradeLogic(analysis)}

${generateMQL5HelperFunctions(analysis)}

${generateMQL5IndicatorFunctions(analysis.indicators)}

${generateMQL5ConditionFunctions(analysis.conditions)}

${generateMQL5TradeManagementFunctions(analysis.advanced)}

//+------------------------------------------------------------------+`
}

function generateMQL4IndicatorInputs(indicators: StrategyNode[]): string {
  if (indicators.length === 0) return ''
  
  const inputs: string[] = ['\ninput group "=== Indicator Settings ==="']
  
  indicators.forEach(node => {
    const data = node.data as any
    const params = data.parameters || {}
    const nodeId = sanitizeNodeId(node.id)
    
    switch (data.indicatorType || node.type) {
      case 'sma':
      case 'ema':
      case 'wma':
        inputs.push(`input int ${nodeId}_Period = ${params.period || 20};`)
        break
      case 'rsi':
        inputs.push(`input int ${nodeId}_Period = ${params.period || 14};`)
        inputs.push(`input int ${nodeId}_Overbought = ${params.overbought || 70};`)
        inputs.push(`input int ${nodeId}_Oversold = ${params.oversold || 30};`)
        break
      case 'macd':
        inputs.push(`input int ${nodeId}_FastPeriod = ${params.fastPeriod || 12};`)
        inputs.push(`input int ${nodeId}_SlowPeriod = ${params.slowPeriod || 26};`)
        inputs.push(`input int ${nodeId}_SignalPeriod = ${params.signalPeriod || 9};`)
        break
      case 'bb':
        inputs.push(`input int ${nodeId}_Period = ${params.period || 20};`)
        inputs.push(`input double ${nodeId}_Deviation = ${params.stdDev || 2.0};`)
        break
      case 'atr':
      case 'cci':
        inputs.push(`input int ${nodeId}_Period = ${params.period || 14};`)
        break
      case 'stochastic':
        inputs.push(`input int ${nodeId}_KPeriod = ${params.kPeriod || 14};`)
        inputs.push(`input int ${nodeId}_DPeriod = ${params.dPeriod || 3};`)
        inputs.push(`input int ${nodeId}_Slowing = ${params.smooth || 3};`)
        break
    }
  })
  
  return inputs.join('\n')
}

function generateMQL5IndicatorInputs(indicators: StrategyNode[]): string {
  return generateMQL4IndicatorInputs(indicators)
}

function generateMQL4RiskInputs(riskNodes: StrategyNode[]): string {
  if (riskNodes.length === 0) return ''
  
  const inputs: string[] = ['\ninput group "=== Risk Management ==="']
  
  riskNodes.forEach(node => {
    const data = node.data as any
    const params = data.parameters || {}
    const nodeId = sanitizeNodeId(node.id)
    
    if (node.type === 'position-size') {
      inputs.push(`input double ${nodeId}_RiskPercent = ${params.riskPercent || 1.0};`)
      inputs.push(`input double ${nodeId}_MaxLotSize = 10.0;`)
    } else if (node.type === 'stop-loss') {
      inputs.push(`input int ${nodeId}_StopLossPips = ${params.pips || 20};`)
    } else if (node.type === 'take-profit') {
      inputs.push(`input int ${nodeId}_TakeProfitPips = ${params.pips || 40};`)
    } else if (node.type === 'trailing-stop') {
      inputs.push(`input int ${nodeId}_TrailingStopPips = ${params.pips || 15};`)
      inputs.push(`input int ${nodeId}_TrailingStepPips = ${params.step || 5};`)
    }
  })
  
  return inputs.join('\n')
}

function generateMQL5RiskInputs(riskNodes: StrategyNode[]): string {
  return generateMQL4RiskInputs(riskNodes)
}

function generateMQL4AdvancedInputs(advancedNodes: StrategyNode[]): string {
  if (advancedNodes.length === 0) return ''
  
  const inputs: string[] = ['\ninput group "=== Advanced Features ==="']
  
  advancedNodes.forEach(node => {
    const data = node.data as any
    const params = data.parameters || {}
    const nodeId = sanitizeNodeId(node.id)
    
    switch (node.type) {
      case 'break_even':
        inputs.push(`input int ${nodeId}_ProfitPips = ${params.profitPips || 20};`)
        inputs.push(`input int ${nodeId}_LockPips = ${params.lockPips || 0};`)
        break
      case 'partial_close':
        inputs.push(`input int ${nodeId}_ProfitPips = ${params.profitPips || 30};`)
        inputs.push(`input int ${nodeId}_ClosePercent = ${params.closePercent || 50};`)
        break
      case 'trailing_stop':
        inputs.push(`input int ${nodeId}_ActivationPips = ${params.activationPips || 20};`)
        inputs.push(`input int ${nodeId}_TrailingPips = ${params.trailingPips || 15};`)
        inputs.push(`input int ${nodeId}_StepPips = ${params.stepPips || 5};`)
        break
      case 'time_stop':
        inputs.push(`input int ${nodeId}_DurationMinutes = ${params.durationMinutes || 60};`)
        break
    }
  })
  
  return inputs.join('\n')
}

function generateMQL5AdvancedInputs(advancedNodes: StrategyNode[]): string {
  return generateMQL4AdvancedInputs(advancedNodes)
}

function generateMQL4GlobalVariables(analysis: GraphAnalysis): string {
  const vars: string[] = []
  
  vars.push('datetime g_lastBarTime = 0;')
  vars.push('bool g_isNewBar = false;')
  
  analysis.variables.forEach(node => {
    const nodeId = sanitizeNodeId(node.id)
    const data = node.data as any
    const params = data.parameters || {}
    
    if (node.type === 'set_variable' || node.type === 'get_variable') {
      const varName = params.variableName || 'myVar'
      vars.push(`double g_${sanitizeVarName(varName)} = 0;`)
    } else if (node.type === 'counter') {
      const counterName = params.counterName || 'count'
      vars.push(`int g_${sanitizeVarName(counterName)} = 0;`)
    }
  })
  
  analysis.advanced.forEach(node => {
    const nodeId = sanitizeNodeId(node.id)
    if (node.type === 'break_even') {
      vars.push(`bool g_${nodeId}_breakEvenSet[];`)
    }
  })
  
  return vars.join('\n')
}

function generateMQL5GlobalVariables(analysis: GraphAnalysis): string {
  const vars: string[] = []
  
  vars.push('datetime g_lastBarTime = 0;')
  vars.push('bool g_isNewBar = false;')
  
  analysis.indicators.forEach(node => {
    const nodeId = sanitizeNodeId(node.id)
    const data = node.data as any
    vars.push(`int g_${nodeId}_handle = INVALID_HANDLE;`)
  })
  
  analysis.variables.forEach(node => {
    const data = node.data as any
    const params = data.parameters || {}
    
    if (node.type === 'set_variable' || node.type === 'get_variable') {
      const varName = params.variableName || 'myVar'
      vars.push(`double g_${sanitizeVarName(varName)} = 0;`)
    } else if (node.type === 'counter') {
      const counterName = params.counterName || 'count'
      vars.push(`int g_${sanitizeVarName(counterName)} = 0;`)
    }
  })
  
  analysis.advanced.forEach(node => {
    const nodeId = sanitizeNodeId(node.id)
    if (node.type === 'break_even') {
      vars.push(`bool g_${nodeId}_breakEvenSet[];`)
    }
  })
  
  return vars.join('\n')
}

function generateMQL4OnInitLogic(analysis: GraphAnalysis): string {
  const logic: string[] = []
  
  const initEvent = analysis.eventNodes.find(n => n.type === 'on_init')
  if (initEvent) {
    const path = analysis.executionPaths.get(initEvent.id) || []
    path.forEach(node => {
      if (node.type === 'on_init') return
      
      const nodeId = sanitizeNodeId(node.id)
      const data = node.data as any
      
      if ((data as any).category === 'variable' && node.type === 'set_variable') {
        const params = data.parameters || {}
        const varName = sanitizeVarName(params.variableName || 'myVar')
        const value = params.value || 0
        logic.push(`   g_${varName} = ${value};`)
      }
    })
  }
  
  return logic.length > 0 ? logic.join('\n') : '   // No initialization logic'
}

function generateMQL5OnInitLogic(analysis: GraphAnalysis): string {
  const logic: string[] = []
  
  analysis.indicators.forEach(node => {
    const nodeId = sanitizeNodeId(node.id)
    const data = node.data as any
    const params = data.parameters || {}
    
    switch (data.indicatorType || node.type) {
      case 'sma':
        logic.push(`   g_${nodeId}_handle = iMA(_Symbol, PERIOD_CURRENT, ${nodeId}_Period, 0, MODE_SMA, PRICE_CLOSE);`)
        break
      case 'ema':
        logic.push(`   g_${nodeId}_handle = iMA(_Symbol, PERIOD_CURRENT, ${nodeId}_Period, 0, MODE_EMA, PRICE_CLOSE);`)
        break
      case 'rsi':
        logic.push(`   g_${nodeId}_handle = iRSI(_Symbol, PERIOD_CURRENT, ${nodeId}_Period, PRICE_CLOSE);`)
        break
      case 'macd':
        logic.push(`   g_${nodeId}_handle = iMACD(_Symbol, PERIOD_CURRENT, ${nodeId}_FastPeriod, ${nodeId}_SlowPeriod, ${nodeId}_SignalPeriod, PRICE_CLOSE);`)
        break
      case 'bb':
        logic.push(`   g_${nodeId}_handle = iBands(_Symbol, PERIOD_CURRENT, ${nodeId}_Period, 0, ${nodeId}_Deviation, PRICE_CLOSE);`)
        break
      case 'atr':
        logic.push(`   g_${nodeId}_handle = iATR(_Symbol, PERIOD_CURRENT, ${nodeId}_Period);`)
        break
    }
  })
  
  const initEvent = analysis.eventNodes.find(n => n.type === 'on_init')
  if (initEvent) {
    const path = analysis.executionPaths.get(initEvent.id) || []
    path.forEach(node => {
      if (node.type === 'on_init') return
      
      const data = node.data as any
      if ((data as any).category === 'variable' && node.type === 'set_variable') {
        const params = data.parameters || {}
        const varName = sanitizeVarName(params.variableName || 'myVar')
        const value = params.value || 0
        logic.push(`   g_${varName} = ${value};`)
      }
    })
  }
  
  return logic.join('\n')
}

function generateMQL4OnDeinitLogic(analysis: GraphAnalysis): string {
  const deinitEvent = analysis.eventNodes.find(n => n.type === 'on_deinit')
  if (!deinitEvent) return '   // No deinitialization logic'
  
  return '   // Cleanup logic'
}

function generateMQL5OnDeinitLogic(analysis: GraphAnalysis): string {
  const logic: string[] = []
  
  analysis.indicators.forEach(node => {
    const nodeId = sanitizeNodeId(node.id)
    logic.push(`   if(g_${nodeId}_handle != INVALID_HANDLE) IndicatorRelease(g_${nodeId}_handle);`)
  })
  
  return logic.join('\n')
}

function generateMQL4OnTickLogic(analysis: GraphAnalysis): string {
  const logic: string[] = []
  
  logic.push('   // Check for new bar')
  logic.push('   g_isNewBar = IsNewBar();')
  logic.push('   if(!g_isNewBar) return;')
  logic.push('')
  logic.push('   // Calculate indicators')
  
  analysis.indicators.forEach(node => {
    const nodeId = sanitizeNodeId(node.id)
    const data = node.data as any
    
    switch (data.indicatorType || node.type) {
      case 'sma':
        logic.push(`   double ${nodeId}_value = iMA(NULL, 0, ${nodeId}_Period, 0, MODE_SMA, PRICE_CLOSE, 1);`)
        break
      case 'ema':
        logic.push(`   double ${nodeId}_value = iMA(NULL, 0, ${nodeId}_Period, 0, MODE_EMA, PRICE_CLOSE, 1);`)
        break
      case 'rsi':
        logic.push(`   double ${nodeId}_value = iRSI(NULL, 0, ${nodeId}_Period, PRICE_CLOSE, 1);`)
        break
      case 'macd':
        logic.push(`   double ${nodeId}_macd = iMACD(NULL, 0, ${nodeId}_FastPeriod, ${nodeId}_SlowPeriod, ${nodeId}_SignalPeriod, PRICE_CLOSE, MODE_MAIN, 1);`)
        logic.push(`   double ${nodeId}_signal = iMACD(NULL, 0, ${nodeId}_FastPeriod, ${nodeId}_SlowPeriod, ${nodeId}_SignalPeriod, PRICE_CLOSE, MODE_SIGNAL, 1);`)
        break
      case 'atr':
        logic.push(`   double ${nodeId}_value = iATR(NULL, 0, ${nodeId}_Period, 1);`)
        break
    }
  })
  
  logic.push('')
  logic.push('   // Evaluate conditions')
  logic.push('   bool buySignal = false;')
  logic.push('   bool sellSignal = false;')
  logic.push('')
  
  const tickEvent = analysis.eventNodes.find(n => n.type === 'on_tick')
  if (tickEvent) {
    const path = analysis.executionPaths.get(tickEvent.id) || []
    logic.push(`   // Strategy logic (${path.length} nodes)`)
    
    const buyAction = analysis.actions.find(n => n.type === 'buy')
    const sellAction = analysis.actions.find(n => n.type === 'sell')
    
    if (analysis.conditions.length > 0) {
      logic.push('   // TODO: Add condition evaluation logic')
      logic.push('   buySignal = false; // Replace with actual condition')
      logic.push('   sellSignal = false; // Replace with actual condition')
    }
  }
  
  logic.push('')
  logic.push('   // Execute trades')
  logic.push('   int openOrders = CountOrders(-1);')
  logic.push('   ')
  logic.push('   if(buySignal && openOrders < MaxOpenTrades)')
  logic.push('   {')
  logic.push('      double sl = Ask - StopLossPips * Point * 10;')
  logic.push('      double tp = Ask + TakeProfitPips * Point * 10;')
  logic.push('      int ticket = OrderSend(Symbol(), OP_BUY, LotSize, Ask, Slippage, sl, tp, ExpertComment, MagicNumber, 0, clrGreen);')
  logic.push('      if(ticket > 0) Print("Buy order opened: ", ticket);')
  logic.push('      else Print("Buy order failed: ", GetLastError());')
  logic.push('   }')
  logic.push('   ')
  logic.push('   if(sellSignal && openOrders < MaxOpenTrades)')
  logic.push('   {')
  logic.push('      double sl = Bid + StopLossPips * Point * 10;')
  logic.push('      double tp = Bid - TakeProfitPips * Point * 10;')
  logic.push('      int ticket = OrderSend(Symbol(), OP_SELL, LotSize, Bid, Slippage, sl, tp, ExpertComment, MagicNumber, 0, clrRed);')
  logic.push('      if(ticket > 0) Print("Sell order opened: ", ticket);')
  logic.push('      else Print("Sell order failed: ", GetLastError());')
  logic.push('   }')
  
  return logic.join('\n')
}

function generateMQL5OnTickLogic(analysis: GraphAnalysis): string {
  const logic: string[] = []
  
  logic.push('   // Check for new bar')
  logic.push('   g_isNewBar = IsNewBar();')
  logic.push('   if(!g_isNewBar) return;')
  logic.push('')
  logic.push('   // Update indicators')
  
  analysis.indicators.forEach(node => {
    const nodeId = sanitizeNodeId(node.id)
    logic.push(`   double ${nodeId}_buffer[];`)
    logic.push(`   if(CopyBuffer(g_${nodeId}_handle, 0, 1, 1, ${nodeId}_buffer) <= 0) return;`)
    logic.push(`   double ${nodeId}_value = ${nodeId}_buffer[0];`)
  })
  
  logic.push('')
  logic.push('   // Evaluate conditions')
  logic.push('   bool buySignal = false;')
  logic.push('   bool sellSignal = false;')
  logic.push('')
  
  const tickEvent = analysis.eventNodes.find(n => n.type === 'on_tick')
  if (tickEvent) {
    const path = analysis.executionPaths.get(tickEvent.id) || []
    logic.push(`   // Strategy logic (${path.length} nodes)`)
    
    if (analysis.conditions.length > 0) {
      logic.push('   // TODO: Add condition evaluation logic')
      logic.push('   buySignal = false; // Replace with actual condition')
      logic.push('   sellSignal = false; // Replace with actual condition')
    }
  }
  
  logic.push('')
  logic.push('   // Execute trades')
  logic.push('   int openPositions = CountPositions();')
  logic.push('   ')
  logic.push('   if(buySignal && openPositions < MaxOpenTrades)')
  logic.push('   {')
  logic.push('      double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);')
  logic.push('      double sl = ask - StopLossPips * _Point * 10;')
  logic.push('      double tp = ask + TakeProfitPips * _Point * 10;')
  logic.push('      if(trade.Buy(LotSize, _Symbol, ask, sl, tp, ExpertComment))')
  logic.push('         Print("Buy order opened");')
  logic.push('      else')
  logic.push('         Print("Buy order failed: ", trade.ResultRetcode());')
  logic.push('   }')
  logic.push('   ')
  logic.push('   if(sellSignal && openPositions < MaxOpenTrades)')
  logic.push('   {')
  logic.push('      double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);')
  logic.push('      double sl = bid + StopLossPips * _Point * 10;')
  logic.push('      double tp = bid - TakeProfitPips * _Point * 10;')
  logic.push('      if(trade.Sell(LotSize, _Symbol, bid, sl, tp, ExpertComment))')
  logic.push('         Print("Sell order opened");')
  logic.push('      else')
  logic.push('         Print("Sell order failed: ", trade.ResultRetcode());')
  logic.push('   }')
  
  return logic.join('\n')
}

function generateMQL4OnTimerLogic(analysis: GraphAnalysis): string {
  const timerEvent = analysis.eventNodes.find(n => n.type === 'on_timer')
  if (!timerEvent) return ''
  
  const data = timerEvent.data as any
  const params = data.parameters || {}
  const intervalSeconds = params.intervalSeconds || 60
  
  return `
//+------------------------------------------------------------------+
//| Timer function                                                    |
//+------------------------------------------------------------------+
void OnTimer()
{
   // Timer logic (interval: ${intervalSeconds}s)
   // Manage trailing stops, break-even, etc.
}
`
}

function generateMQL5OnTimerLogic(analysis: GraphAnalysis): string {
  return generateMQL4OnTimerLogic(analysis)
}

function generateMQL4OnTradeLogic(analysis: GraphAnalysis): string {
  const tradeEvent = analysis.eventNodes.find(n => n.type === 'on_trade')
  if (!tradeEvent) return ''
  
  return `
//+------------------------------------------------------------------+
//| Trade transaction function                                        |
//+------------------------------------------------------------------+
void OnTrade()
{
   // Trade event logic
   // React to trade opens/closes
}
`
}

function generateMQL5OnTradeLogic(analysis: GraphAnalysis): string {
  const tradeEvent = analysis.eventNodes.find(n => n.type === 'on_trade')
  if (!tradeEvent) return ''
  
  return `
//+------------------------------------------------------------------+
//| Trade transaction function                                        |
//+------------------------------------------------------------------+
void OnTradeTransaction(const MqlTradeTransaction& trans,
                        const MqlTradeRequest& request,
                        const MqlTradeResult& result)
{
   // Trade event logic
   // React to trade opens/closes
}
`
}

function generateMQL4HelperFunctions(analysis: GraphAnalysis): string {
  return `
//+------------------------------------------------------------------+
//| Helper Functions                                                  |
//+------------------------------------------------------------------+

bool IsNewBar()
{
   datetime currentBarTime = iTime(NULL, 0, 0);
   if(g_lastBarTime != currentBarTime)
   {
      g_lastBarTime = currentBarTime;
      return true;
   }
   return false;
}

int CountOrders(int orderType)
{
   int count = 0;
   for(int i = OrdersTotal() - 1; i >= 0; i--)
   {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
      {
         if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber)
         {
            if(orderType == -1 || OrderType() == orderType)
               count++;
         }
      }
   }
   return count;
}

double CalculateLotSize(double riskPercent, double stopLossPips)
{
   double accountBalance = AccountBalance();
   double riskAmount = accountBalance * riskPercent / 100.0;
   
   double tickValue = MarketInfo(Symbol(), MODE_TICKVALUE);
   double tickSize = MarketInfo(Symbol(), MODE_TICKSIZE);
   double lotSize = riskAmount / (stopLossPips * tickValue / tickSize);
   
   double minLot = MarketInfo(Symbol(), MODE_MINLOT);
   double maxLot = MarketInfo(Symbol(), MODE_MAXLOT);
   double lotStep = MarketInfo(Symbol(), MODE_LOTSTEP);
   
   lotSize = MathMax(minLot, MathMin(maxLot, MathFloor(lotSize / lotStep) * lotStep));
   
   return lotSize;
}

double PipsToPrice(double pips)
{
   double digits = MarketInfo(Symbol(), MODE_DIGITS);
   double pipValue = (digits == 3 || digits == 5) ? Point * 10 : Point;
   return pips * pipValue;
}

double PriceToPips(double price)
{
   double digits = MarketInfo(Symbol(), MODE_DIGITS);
   double pipValue = (digits == 3 || digits == 5) ? Point * 10 : Point;
   return price / pipValue;
}
`
}

function generateMQL5HelperFunctions(analysis: GraphAnalysis): string {
  return `
//+------------------------------------------------------------------+
//| Helper Functions                                                  |
//+------------------------------------------------------------------+

bool IsNewBar()
{
   datetime currentBarTime = iTime(_Symbol, PERIOD_CURRENT, 0);
   if(g_lastBarTime != currentBarTime)
   {
      g_lastBarTime = currentBarTime;
      return true;
   }
   return false;
}

int CountPositions(ENUM_POSITION_TYPE posType = -1)
{
   int count = 0;
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         if(PositionGetString(POSITION_SYMBOL) == _Symbol && 
            PositionGetInteger(POSITION_MAGIC) == MagicNumber)
         {
            if(posType == -1 || PositionGetInteger(POSITION_TYPE) == posType)
               count++;
         }
      }
   }
   return count;
}

double CalculateLotSize(double riskPercent, double stopLossPips)
{
   double accountBalance = AccountInfoDouble(ACCOUNT_BALANCE);
   double riskAmount = accountBalance * riskPercent / 100.0;
   
   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double lotSize = riskAmount / (stopLossPips * tickValue / tickSize);
   
   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   
   lotSize = MathMax(minLot, MathMin(maxLot, MathFloor(lotSize / lotStep) * lotStep));
   
   return lotSize;
}

double PipsToPrice(double pips)
{
   return pips * _Point * 10;
}

double PriceToPips(double price)
{
   return price / (_Point * 10);
}
`
}

function generateMQL4IndicatorFunctions(indicators: StrategyNode[]): string {
  return '// Indicator calculation functions integrated in OnTick'
}

function generateMQL5IndicatorFunctions(indicators: StrategyNode[]): string {
  return '// Indicator handles initialized in OnInit'
}

function generateMQL4ConditionFunctions(conditions: StrategyNode[]): string {
  return '// Condition evaluation functions'
}

function generateMQL5ConditionFunctions(conditions: StrategyNode[]): string {
  return '// Condition evaluation functions'
}

function generateMQL4TradeManagementFunctions(advancedNodes: StrategyNode[]): string {
  if (advancedNodes.length === 0) return ''
  
  const funcs: string[] = []
  
  const hasBreakEven = advancedNodes.some(n => n.type === 'break_even')
  const hasTrailing = advancedNodes.some(n => n.type === 'trailing_stop')
  const hasPartialClose = advancedNodes.some(n => n.type === 'partial_close')
  
  if (hasBreakEven) {
    funcs.push(`
//+------------------------------------------------------------------+
//| Move stop loss to break even                                     |
//+------------------------------------------------------------------+
void MoveToBreakEven(int profitPips, int lockPips)
{
   for(int i = OrdersTotal() - 1; i >= 0; i--)
   {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
      {
         if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber)
         {
            double currentProfitPips = 0;
            
            if(OrderType() == OP_BUY)
               currentProfitPips = (Bid - OrderOpenPrice()) / (Point * 10);
            else if(OrderType() == OP_SELL)
               currentProfitPips = (OrderOpenPrice() - Ask) / (Point * 10);
            
            if(currentProfitPips >= profitPips)
            {
               double newSL = OrderOpenPrice() + lockPips * Point * 10;
               
               if(OrderType() == OP_BUY && newSL > OrderStopLoss())
                  OrderModify(OrderTicket(), OrderOpenPrice(), newSL, OrderTakeProfit(), 0, clrBlue);
               else if(OrderType() == OP_SELL && (OrderStopLoss() == 0 || newSL < OrderStopLoss()))
                  OrderModify(OrderTicket(), OrderOpenPrice(), newSL, OrderTakeProfit(), 0, clrBlue);
            }
         }
      }
   }
}
`)
  }
  
  if (hasTrailing) {
    funcs.push(`
//+------------------------------------------------------------------+
//| Apply trailing stop                                              |
//+------------------------------------------------------------------+
void ApplyTrailingStop(int activationPips, int trailingPips, int stepPips)
{
   for(int i = OrdersTotal() - 1; i >= 0; i--)
   {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
      {
         if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber)
         {
            double currentProfitPips = 0;
            
            if(OrderType() == OP_BUY)
            {
               currentProfitPips = (Bid - OrderOpenPrice()) / (Point * 10);
               if(currentProfitPips >= activationPips)
               {
                  double newSL = Bid - trailingPips * Point * 10;
                  if(newSL > OrderStopLoss() + stepPips * Point * 10)
                     OrderModify(OrderTicket(), OrderOpenPrice(), newSL, OrderTakeProfit(), 0, clrBlue);
               }
            }
            else if(OrderType() == OP_SELL)
            {
               currentProfitPips = (OrderOpenPrice() - Ask) / (Point * 10);
               if(currentProfitPips >= activationPips)
               {
                  double newSL = Ask + trailingPips * Point * 10;
                  if(OrderStopLoss() == 0 || newSL < OrderStopLoss() - stepPips * Point * 10)
                     OrderModify(OrderTicket(), OrderOpenPrice(), newSL, OrderTakeProfit(), 0, clrBlue);
               }
            }
         }
      }
   }
}
`)
  }
  
  return funcs.join('\n')
}

function generateMQL5TradeManagementFunctions(advancedNodes: StrategyNode[]): string {
  if (advancedNodes.length === 0) return ''
  
  const funcs: string[] = []
  
  const hasBreakEven = advancedNodes.some(n => n.type === 'break_even')
  const hasTrailing = advancedNodes.some(n => n.type === 'trailing_stop')
  
  if (hasBreakEven) {
    funcs.push(`
//+------------------------------------------------------------------+
//| Move stop loss to break even                                     |
//+------------------------------------------------------------------+
void MoveToBreakEven(int profitPips, int lockPips)
{
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         if(PositionGetString(POSITION_SYMBOL) == _Symbol && 
            PositionGetInteger(POSITION_MAGIC) == MagicNumber)
         {
            double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
            double currentSL = PositionGetDouble(POSITION_SL);
            ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            
            double currentProfitPips = 0;
            
            if(posType == POSITION_TYPE_BUY)
               currentProfitPips = (SymbolInfoDouble(_Symbol, SYMBOL_BID) - openPrice) / (_Point * 10);
            else
               currentProfitPips = (openPrice - SymbolInfoDouble(_Symbol, SYMBOL_ASK)) / (_Point * 10);
            
            if(currentProfitPips >= profitPips)
            {
               double newSL = openPrice + lockPips * _Point * 10;
               
               if(posType == POSITION_TYPE_BUY && newSL > currentSL)
                  trade.PositionModify(ticket, newSL, PositionGetDouble(POSITION_TP));
               else if(posType == POSITION_TYPE_SELL && (currentSL == 0 || newSL < currentSL))
                  trade.PositionModify(ticket, newSL, PositionGetDouble(POSITION_TP));
            }
         }
      }
   }
}
`)
  }
  
  if (hasTrailing) {
    funcs.push(`
//+------------------------------------------------------------------+
//| Apply trailing stop                                              |
//+------------------------------------------------------------------+
void ApplyTrailingStop(int activationPips, int trailingPips, int stepPips)
{
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         if(PositionGetString(POSITION_SYMBOL) == _Symbol && 
            PositionGetInteger(POSITION_MAGIC) == MagicNumber)
         {
            double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
            double currentSL = PositionGetDouble(POSITION_SL);
            ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            
            double currentProfitPips = 0;
            
            if(posType == POSITION_TYPE_BUY)
            {
               currentProfitPips = (SymbolInfoDouble(_Symbol, SYMBOL_BID) - openPrice) / (_Point * 10);
               if(currentProfitPips >= activationPips)
               {
                  double newSL = SymbolInfoDouble(_Symbol, SYMBOL_BID) - trailingPips * _Point * 10;
                  if(newSL > currentSL + stepPips * _Point * 10)
                     trade.PositionModify(ticket, newSL, PositionGetDouble(POSITION_TP));
               }
            }
            else
            {
               currentProfitPips = (openPrice - SymbolInfoDouble(_Symbol, SYMBOL_ASK)) / (_Point * 10);
               if(currentProfitPips >= activationPips)
               {
                  double newSL = SymbolInfoDouble(_Symbol, SYMBOL_ASK) + trailingPips * _Point * 10;
                  if(currentSL == 0 || newSL < currentSL - stepPips * _Point * 10)
                     trade.PositionModify(ticket, newSL, PositionGetDouble(POSITION_TP));
               }
            }
         }
      }
   }
}
`)
  }
  
  return funcs.join('\n')
}

function sanitizeNodeId(id: string): string {
  return id.replace(/[^a-zA-Z0-9_]/g, '_')
}

function sanitizeVarName(name: string): string {
  return name.replace(/[^a-zA-Z0-9_]/g, '_')
}

export {
  sanitizeNodeId,
  sanitizeVarName,
  analyzeStrategyGraph
}
