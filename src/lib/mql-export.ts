import { Strategy } from '@/types/strategy'
import { Node, Edge } from '@xyflow/react'

export type MQLVersion = 'mql4' | 'mql5'

interface MQLExportOptions {
  version: MQLVersion
  expertName: string
  magicNumber: number
}

export function exportToMQL(strategy: Strategy, options: MQLExportOptions): string {
  if (options.version === 'mql4') {
    return generateMQL4(strategy, options)
  } else {
    return generateMQL5(strategy, options)
  }
}

function generateMQL4(strategy: Strategy, options: MQLExportOptions): string {
  const { expertName, magicNumber } = options
  const nodes = strategy.nodes
  const edges = strategy.edges

  const indicators = nodes.filter(n => n.type === 'indicator')
  const conditions = nodes.filter(n => n.type === 'condition')
  const actions = nodes.filter(n => n.type === 'action')
  const riskNodes = nodes.filter(n => n.type === 'risk')

  const code = `//+------------------------------------------------------------------+
//|                                              ${expertName}.mq4 |
//|                        Generated by ForexFlow Visual Bot Builder |
//|                                      https://github.com/forexflow |
//+------------------------------------------------------------------+
#property copyright "Generated by ForexFlow"
#property link      "https://github.com/forexflow"
#property version   "1.00"
#property strict

//--- Input Parameters
input int MagicNumber = ${magicNumber};
input double LotSize = 0.01;
input int Slippage = 3;

${generateIndicatorInputs(indicators)}
${generateRiskInputs(riskNodes)}

//--- Global Variables
${generateGlobalVariables(indicators)}

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   Print("${expertName} initialized successfully");
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   Print("${expertName} deinitialized");
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   ${generateIndicatorCalculations(indicators)}
   
   ${generateConditionChecks(conditions, edges, nodes)}
   
   ${generateTradeLogic(actions, edges, nodes)}
}

${generateHelperFunctions()}

//+------------------------------------------------------------------+
`

  return code
}

function generateMQL5(strategy: Strategy, options: MQLExportOptions): string {
  const { expertName, magicNumber } = options
  const nodes = strategy.nodes
  const edges = strategy.edges

  const indicators = nodes.filter(n => n.type === 'indicator')
  const conditions = nodes.filter(n => n.type === 'condition')
  const actions = nodes.filter(n => n.type === 'action')
  const riskNodes = nodes.filter(n => n.type === 'risk')

  const code = `//+------------------------------------------------------------------+
//|                                              ${expertName}.mq5 |
//|                        Generated by ForexFlow Visual Bot Builder |
//|                                      https://github.com/forexflow |
//+------------------------------------------------------------------+
#property copyright "Generated by ForexFlow"
#property link      "https://github.com/forexflow"
#property version   "1.00"

#include <Trade\\Trade.mqh>

//--- Input Parameters
input int MagicNumber = ${magicNumber};
input double LotSize = 0.01;
input int Slippage = 3;

${generateIndicatorInputs(indicators)}
${generateRiskInputs(riskNodes)}

//--- Global Variables
CTrade trade;
${generateGlobalVariablesMQL5(indicators)}

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   trade.SetExpertMagicNumber(MagicNumber);
   trade.SetDeviationInPoints(Slippage);
   
   Print("${expertName} initialized successfully");
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   Print("${expertName} deinitialized");
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   ${generateIndicatorCalculationsMQL5(indicators)}
   
   ${generateConditionChecksMQL5(conditions, edges, nodes)}
   
   ${generateTradeLogicMQL5(actions, edges, nodes)}
}

${generateHelperFunctionsMQL5()}

//+------------------------------------------------------------------+
`

  return code
}

function generateIndicatorInputs(indicators: Node[]): string {
  const inputs: string[] = []
  
  indicators.forEach(node => {
    const data = node.data as any
    const params = data.parameters || {}
    
    switch (node.id.split('_')[0]) {
      case 'sma':
      case 'ema':
      case 'wma':
        inputs.push(`input int MA_Period_${node.id} = ${params.period || 20};`)
        break
      case 'rsi':
        inputs.push(`input int RSI_Period_${node.id} = ${params.period || 14};`)
        inputs.push(`input int RSI_Overbought_${node.id} = ${params.overbought || 70};`)
        inputs.push(`input int RSI_Oversold_${node.id} = ${params.oversold || 30};`)
        break
      case 'macd':
        inputs.push(`input int MACD_Fast_${node.id} = ${params.fastPeriod || 12};`)
        inputs.push(`input int MACD_Slow_${node.id} = ${params.slowPeriod || 26};`)
        inputs.push(`input int MACD_Signal_${node.id} = ${params.signalPeriod || 9};`)
        break
      case 'bb':
        inputs.push(`input int BB_Period_${node.id} = ${params.period || 20};`)
        inputs.push(`input double BB_Deviation_${node.id} = ${params.stdDev || 2.0};`)
        break
      case 'atr':
        inputs.push(`input int ATR_Period_${node.id} = ${params.period || 14};`)
        break
    }
  })
  
  return inputs.join('\n')
}

function generateRiskInputs(riskNodes: Node[]): string {
  const inputs: string[] = []
  
  riskNodes.forEach(node => {
    const data = node.data as any
    const params = data.parameters || {}
    
    switch (node.id.split('_')[0]) {
      case 'stop':
        inputs.push(`input int StopLoss_Pips_${node.id} = ${params.pips || 20};`)
        break
      case 'take':
        inputs.push(`input int TakeProfit_Pips_${node.id} = ${params.pips || 40};`)
        break
      case 'trailing':
        inputs.push(`input int TrailingStop_Pips_${node.id} = ${params.pips || 15};`)
        inputs.push(`input int TrailingStep_Pips_${node.id} = ${params.step || 5};`)
        break
      case 'position':
        inputs.push(`input double RiskPercent_${node.id} = ${params.riskPercent || 1.0};`)
        break
    }
  })
  
  return inputs.join('\n')
}

function generateGlobalVariables(indicators: Node[]): string {
  const vars: string[] = []
  
  indicators.forEach(node => {
    const nodeType = node.id.split('_')[0]
    switch (nodeType) {
      case 'sma':
      case 'ema':
      case 'wma':
        vars.push(`double ${nodeType}_${node.id}[];`)
        break
      case 'rsi':
        vars.push(`double rsi_${node.id}[];`)
        break
      case 'macd':
        vars.push(`double macd_main_${node.id}[], macd_signal_${node.id}[];`)
        break
      case 'bb':
        vars.push(`double bb_upper_${node.id}[], bb_middle_${node.id}[], bb_lower_${node.id}[];`)
        break
      case 'atr':
        vars.push(`double atr_${node.id}[];`)
        break
    }
  })
  
  return vars.join('\n')
}

function generateGlobalVariablesMQL5(indicators: Node[]): string {
  const vars: string[] = []
  
  indicators.forEach(node => {
    const nodeType = node.id.split('_')[0]
    switch (nodeType) {
      case 'sma':
      case 'ema':
      case 'wma':
        vars.push(`int handle_${node.id};`)
        vars.push(`double ${nodeType}_${node.id}[];`)
        break
      case 'rsi':
        vars.push(`int handle_rsi_${node.id};`)
        vars.push(`double rsi_${node.id}[];`)
        break
      case 'macd':
        vars.push(`int handle_macd_${node.id};`)
        vars.push(`double macd_main_${node.id}[], macd_signal_${node.id}[];`)
        break
      case 'bb':
        vars.push(`int handle_bb_${node.id};`)
        vars.push(`double bb_upper_${node.id}[], bb_middle_${node.id}[], bb_lower_${node.id}[];`)
        break
      case 'atr':
        vars.push(`int handle_atr_${node.id};`)
        vars.push(`double atr_${node.id}[];`)
        break
    }
  })
  
  return vars.join('\n')
}

function generateIndicatorCalculations(indicators: Node[]): string {
  const calcs: string[] = []
  
  indicators.forEach(node => {
    const data = node.data as any
    const params = data.parameters || {}
    const nodeType = node.id.split('_')[0]
    
    switch (nodeType) {
      case 'sma':
        calcs.push(`   double sma_${node.id} = iMA(NULL, 0, MA_Period_${node.id}, 0, MODE_SMA, PRICE_CLOSE, 0);`)
        break
      case 'ema':
        calcs.push(`   double ema_${node.id} = iMA(NULL, 0, MA_Period_${node.id}, 0, MODE_EMA, PRICE_CLOSE, 0);`)
        break
      case 'wma':
        calcs.push(`   double wma_${node.id} = iMA(NULL, 0, MA_Period_${node.id}, 0, MODE_LWMA, PRICE_CLOSE, 0);`)
        break
      case 'rsi':
        calcs.push(`   double rsi_${node.id} = iRSI(NULL, 0, RSI_Period_${node.id}, PRICE_CLOSE, 0);`)
        break
      case 'macd':
        calcs.push(`   double macd_main_${node.id} = iMACD(NULL, 0, MACD_Fast_${node.id}, MACD_Slow_${node.id}, MACD_Signal_${node.id}, PRICE_CLOSE, MODE_MAIN, 0);`)
        calcs.push(`   double macd_signal_${node.id} = iMACD(NULL, 0, MACD_Fast_${node.id}, MACD_Slow_${node.id}, MACD_Signal_${node.id}, PRICE_CLOSE, MODE_SIGNAL, 0);`)
        break
      case 'bb':
        calcs.push(`   double bb_upper_${node.id} = iBands(NULL, 0, BB_Period_${node.id}, BB_Deviation_${node.id}, 0, PRICE_CLOSE, MODE_UPPER, 0);`)
        calcs.push(`   double bb_middle_${node.id} = iBands(NULL, 0, BB_Period_${node.id}, BB_Deviation_${node.id}, 0, PRICE_CLOSE, MODE_MAIN, 0);`)
        calcs.push(`   double bb_lower_${node.id} = iBands(NULL, 0, BB_Period_${node.id}, BB_Deviation_${node.id}, 0, PRICE_CLOSE, MODE_LOWER, 0);`)
        break
      case 'atr':
        calcs.push(`   double atr_${node.id} = iATR(NULL, 0, ATR_Period_${node.id}, 0);`)
        break
    }
  })
  
  return calcs.join('\n')
}

function generateIndicatorCalculationsMQL5(indicators: Node[]): string {
  const calcs: string[] = []
  
  indicators.forEach(node => {
    const nodeType = node.id.split('_')[0]
    
    switch (nodeType) {
      case 'sma':
      case 'ema':
      case 'wma':
        calcs.push(`   CopyBuffer(handle_${node.id}, 0, 0, 1, ${nodeType}_${node.id});`)
        break
      case 'rsi':
        calcs.push(`   CopyBuffer(handle_rsi_${node.id}, 0, 0, 1, rsi_${node.id});`)
        break
      case 'macd':
        calcs.push(`   CopyBuffer(handle_macd_${node.id}, 0, 0, 1, macd_main_${node.id});`)
        calcs.push(`   CopyBuffer(handle_macd_${node.id}, 1, 0, 1, macd_signal_${node.id});`)
        break
      case 'bb':
        calcs.push(`   CopyBuffer(handle_bb_${node.id}, 0, 0, 1, bb_upper_${node.id});`)
        calcs.push(`   CopyBuffer(handle_bb_${node.id}, 1, 0, 1, bb_middle_${node.id});`)
        calcs.push(`   CopyBuffer(handle_bb_${node.id}, 2, 0, 1, bb_lower_${node.id});`)
        break
      case 'atr':
        calcs.push(`   CopyBuffer(handle_atr_${node.id}, 0, 0, 1, atr_${node.id});`)
        break
    }
  })
  
  return calcs.join('\n')
}

function generateConditionChecks(conditions: Node[], edges: Edge[], nodes: Node[]): string {
  const checks: string[] = []
  
  checks.push('   // Condition Checks')
  checks.push('   bool buyCondition = false;')
  checks.push('   bool sellCondition = false;')
  checks.push('')
  
  conditions.forEach(node => {
    const nodeType = node.id.split('_')[0]
    const data = node.data as any
    const params = data.parameters || {}
    
    const incomingEdges = edges.filter(e => e.target === node.id)
    
    if (incomingEdges.length >= 2) {
      const sourceNodes = incomingEdges.map(e => nodes.find(n => n.id === e.source))
      checks.push(`   // Condition: ${data.label || node.id}`)
    }
  })
  
  return checks.join('\n')
}

function generateConditionChecksMQL5(conditions: Node[], edges: Edge[], nodes: Node[]): string {
  return generateConditionChecks(conditions, edges, nodes)
}

function generateTradeLogic(actions: Node[], edges: Edge[], nodes: Node[]): string {
  const logic: string[] = []
  
  logic.push('')
  logic.push('   // Trade Execution')
  logic.push('   if(buyCondition && OrdersTotal() == 0)')
  logic.push('   {')
  logic.push('      double sl = Ask - StopLoss_Pips * Point * 10;')
  logic.push('      double tp = Ask + TakeProfit_Pips * Point * 10;')
  logic.push('      int ticket = OrderSend(Symbol(), OP_BUY, LotSize, Ask, Slippage, sl, tp, "ForexFlow Buy", MagicNumber, 0, clrGreen);')
  logic.push('      if(ticket > 0)')
  logic.push('         Print("Buy order opened successfully");')
  logic.push('   }')
  logic.push('')
  logic.push('   if(sellCondition && OrdersTotal() == 0)')
  logic.push('   {')
  logic.push('      double sl = Bid + StopLoss_Pips * Point * 10;')
  logic.push('      double tp = Bid - TakeProfit_Pips * Point * 10;')
  logic.push('      int ticket = OrderSend(Symbol(), OP_SELL, LotSize, Bid, Slippage, sl, tp, "ForexFlow Sell", MagicNumber, 0, clrRed);')
  logic.push('      if(ticket > 0)')
  logic.push('         Print("Sell order opened successfully");')
  logic.push('   }')
  
  return logic.join('\n')
}

function generateTradeLogicMQL5(actions: Node[], edges: Edge[], nodes: Node[]): string {
  const logic: string[] = []
  
  logic.push('')
  logic.push('   // Trade Execution')
  logic.push('   if(buyCondition && PositionsTotal() == 0)')
  logic.push('   {')
  logic.push('      double sl = SymbolInfoDouble(_Symbol, SYMBOL_ASK) - StopLoss_Pips * _Point * 10;')
  logic.push('      double tp = SymbolInfoDouble(_Symbol, SYMBOL_ASK) + TakeProfit_Pips * _Point * 10;')
  logic.push('      if(trade.Buy(LotSize, _Symbol, 0, sl, tp, "ForexFlow Buy"))')
  logic.push('         Print("Buy order opened successfully");')
  logic.push('   }')
  logic.push('')
  logic.push('   if(sellCondition && PositionsTotal() == 0)')
  logic.push('   {')
  logic.push('      double sl = SymbolInfoDouble(_Symbol, SYMBOL_BID) + StopLoss_Pips * _Point * 10;')
  logic.push('      double tp = SymbolInfoDouble(_Symbol, SYMBOL_BID) - TakeProfit_Pips * _Point * 10;')
  logic.push('      if(trade.Sell(LotSize, _Symbol, 0, sl, tp, "ForexFlow Sell"))')
  logic.push('         Print("Sell order opened successfully");')
  logic.push('   }')
  
  return logic.join('\n')
}

function generateHelperFunctions(): string {
  return `//+------------------------------------------------------------------+
//| Helper Functions                                                 |
//+------------------------------------------------------------------+
bool IsNewBar()
{
   static datetime lastBar = 0;
   datetime currentBar = iTime(NULL, 0, 0);
   
   if(lastBar != currentBar)
   {
      lastBar = currentBar;
      return true;
   }
   return false;
}

int CountOrders(int orderType)
{
   int count = 0;
   for(int i = OrdersTotal() - 1; i >= 0; i--)
   {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
      {
         if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber)
         {
            if(orderType == -1 || OrderType() == orderType)
               count++;
         }
      }
   }
   return count;
}`
}

function generateHelperFunctionsMQL5(): string {
  return `//+------------------------------------------------------------------+
//| Helper Functions                                                 |
//+------------------------------------------------------------------+
bool IsNewBar()
{
   static datetime lastBar = 0;
   datetime currentBar = iTime(_Symbol, PERIOD_CURRENT, 0);
   
   if(lastBar != currentBar)
   {
      lastBar = currentBar;
      return true;
   }
   return false;
}

int CountPositions(ENUM_POSITION_TYPE posType = -1)
{
   int count = 0;
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      if(PositionSelectByTicket(PositionGetTicket(i)))
      {
         if(PositionGetString(POSITION_SYMBOL) == _Symbol && 
            PositionGetInteger(POSITION_MAGIC) == MagicNumber)
         {
            if(posType == -1 || PositionGetInteger(POSITION_TYPE) == posType)
               count++;
         }
      }
   }
   return count;
}`
}
