import { Strategy } from '@/types/strategy'
import { Node, Edge } from '@xyflow/react'

export type MQLVersion = 'mql4' | 'mql5'

interface MQLExportOptions {
  version: MQLVersion
  expertName: string
  magicNumber: number
}

export function exportToMQL(strategy: Strategy, options: MQLExportOptions): string {
  if (options.version === 'mql4') {
    return generateMQL4(strategy, options)
  } else {
    return generateMQL5(strategy, options)
  }
}

function generateMQL4(strategy: Strategy, options: MQLExportOptions): string {
  const { expertName, magicNumber } = options
  const nodes = strategy.nodes
  const edges = strategy.edges

  const indicators = nodes.filter(n => n.type === 'indicator')
  const conditions = nodes.filter(n => n.type === 'condition')
  const actions = nodes.filter(n => n.type === 'action')
  const riskNodes = nodes.filter(n => n.type === 'risk')

  const code = `//+------------------------------------------------------------------+
//|                                              ${expertName}.mq4 |
//|                        Generated by ForexFlow Visual Bot Builder |
//|                                      https://github.com/forexflow |
//+------------------------------------------------------------------+
#property copyright "Generated by ForexFlow"
#property link      "https://github.com/forexflow"
#property version   "1.00"
#property strict

//--- Input Parameters
input int MagicNumber = ${magicNumber};
input double LotSize = 0.01;
input int Slippage = 3;

${generateIndicatorInputs(indicators)}
${generateRiskInputs(riskNodes)}

//--- Global Variables
${generateGlobalVariables(indicators)}

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   Print("${expertName} initialized successfully");
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   Print("${expertName} deinitialized");
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   ${generateIndicatorCalculations(indicators)}
   
   ${generateConditionChecks(conditions, edges, nodes)}
   
   ${generateTradeLogic(actions, edges, nodes)}
}

${generateHelperFunctions()}

//+------------------------------------------------------------------+
`

  return code
}

function generateMQL5(strategy: Strategy, options: MQLExportOptions): string {
  const { expertName, magicNumber } = options
  const nodes = strategy.nodes
  const edges = strategy.edges

  const indicators = nodes.filter(n => n.type === 'indicator')
  const conditions = nodes.filter(n => n.type === 'condition')
  const actions = nodes.filter(n => n.type === 'action')
  const riskNodes = nodes.filter(n => n.type === 'risk')

  const code = `//+------------------------------------------------------------------+
//|                                              ${expertName}.mq5 |
//|                        Generated by ForexFlow Visual Bot Builder |
//|                                      https://github.com/forexflow |
//+------------------------------------------------------------------+
#property copyright "Generated by ForexFlow"
#property link      "https://github.com/forexflow"
#property version   "1.00"

#include <Trade\\Trade.mqh>

//--- Input Parameters
input int MagicNumber = ${magicNumber};
input double LotSize = 0.01;
input int Slippage = 3;

${generateIndicatorInputs(indicators)}
${generateRiskInputs(riskNodes)}

//--- Global Variables
CTrade trade;
${generateGlobalVariablesMQL5(indicators)}

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   trade.SetExpertMagicNumber(MagicNumber);
   trade.SetDeviationInPoints(Slippage);
   
   Print("${expertName} initialized successfully");
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   Print("${expertName} deinitialized");
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   ${generateIndicatorCalculationsMQL5(indicators)}
   
   ${generateConditionChecksMQL5(conditions, edges, nodes)}
   
   ${generateTradeLogicMQL5(actions, edges, nodes)}
}

${generateHelperFunctionsMQL5()}

//+------------------------------------------------------------------+
`

  return code
}

function generateIndicatorInputs(indicators: Node[]): string {
  const inputs: string[] = []
  
  indicators.forEach(node => {
    const data = node.data as any
    const params = data.parameters || {}
    const indicatorType = data.indicatorType || node.id.split('_')[0]
    
    switch (indicatorType) {
      case 'sma':
      case 'ema':
      case 'wma':
        inputs.push(`input int MA_Period_${node.id} = ${params.period || 20};`)
        break
      case 'rsi':
        inputs.push(`input int RSI_Period_${node.id} = ${params.period || 14};`)
        inputs.push(`input int RSI_Overbought_${node.id} = ${params.overbought || 70};`)
        inputs.push(`input int RSI_Oversold_${node.id} = ${params.oversold || 30};`)
        break
      case 'macd':
        inputs.push(`input int MACD_Fast_${node.id} = ${params.fastPeriod || 12};`)
        inputs.push(`input int MACD_Slow_${node.id} = ${params.slowPeriod || 26};`)
        inputs.push(`input int MACD_Signal_${node.id} = ${params.signalPeriod || 9};`)
        break
      case 'bb':
        inputs.push(`input int BB_Period_${node.id} = ${params.period || 20};`)
        inputs.push(`input double BB_Deviation_${node.id} = ${params.stdDev || 2.0};`)
        break
      case 'atr':
        inputs.push(`input int ATR_Period_${node.id} = ${params.period || 14};`)
        break
      case 'stochastic':
        inputs.push(`input int Stoch_K_Period_${node.id} = ${params.kPeriod || 14};`)
        inputs.push(`input int Stoch_D_Period_${node.id} = ${params.dPeriod || 3};`)
        inputs.push(`input int Stoch_Slowing_${node.id} = ${params.slowing || 3};`)
        break
      case 'cci':
        inputs.push(`input int CCI_Period_${node.id} = ${params.period || 14};`)
        break
      case 'adx':
        inputs.push(`input int ADX_Period_${node.id} = ${params.period || 14};`)
        break
      case 'williams':
        inputs.push(`input int Williams_Period_${node.id} = ${params.period || 14};`)
        break
      case 'sar':
        inputs.push(`input double SAR_Step_${node.id} = ${params.step || 0.02};`)
        inputs.push(`input double SAR_Maximum_${node.id} = ${params.maximum || 0.2};`)
        break
      case 'obv':
        break
      case 'vwap':
        break
    }
  })
  
  return inputs.join('\n')
}

function generateRiskInputs(riskNodes: Node[]): string {
  const inputs: string[] = []
  
  let hasStopLoss = false
  let hasTakeProfit = false
  
  riskNodes.forEach(node => {
    const data = node.data as any
    const params = data.parameters || {}
    const riskType = data.riskType || node.id.split('_')[0]
    
    switch (riskType) {
      case 'stop':
      case 'stop_loss':
        if (!hasStopLoss) {
          inputs.push(`input int StopLoss_Pips = ${params.pips || 20};`)
          hasStopLoss = true
        }
        break
      case 'take':
      case 'take_profit':
        if (!hasTakeProfit) {
          inputs.push(`input int TakeProfit_Pips = ${params.pips || 40};`)
          hasTakeProfit = true
        }
        break
      case 'trailing':
      case 'trailing_stop':
        inputs.push(`input int TrailingStop_Pips = ${params.pips || 15};`)
        inputs.push(`input int TrailingStep_Pips = ${params.step || 5};`)
        break
      case 'position':
      case 'position_size':
        inputs.push(`input double RiskPercent = ${params.riskPercent || 1.0};`)
        break
    }
  })
  
  if (!hasStopLoss) {
    inputs.push(`input int StopLoss_Pips = 20;`)
  }
  if (!hasTakeProfit) {
    inputs.push(`input int TakeProfit_Pips = 40;`)
  }
  
  return inputs.join('\n')
}

function generateGlobalVariables(indicators: Node[]): string {
  const vars: string[] = []
  
  indicators.forEach(node => {
    const data = node.data as any
    const indicatorType = data.indicatorType || node.id.split('_')[0]
    
    switch (indicatorType) {
      case 'sma':
      case 'ema':
      case 'wma':
        vars.push(`double ${indicatorType}_${node.id}[];`)
        break
      case 'rsi':
        vars.push(`double rsi_${node.id}[];`)
        break
      case 'macd':
        vars.push(`double macd_main_${node.id}[], macd_signal_${node.id}[];`)
        break
      case 'bb':
        vars.push(`double bb_upper_${node.id}[], bb_middle_${node.id}[], bb_lower_${node.id}[];`)
        break
      case 'atr':
        vars.push(`double atr_${node.id}[];`)
        break
      case 'stochastic':
        vars.push(`double stoch_main_${node.id}[], stoch_signal_${node.id}[];`)
        break
      case 'cci':
        vars.push(`double cci_${node.id}[];`)
        break
      case 'adx':
        vars.push(`double adx_${node.id}[];`)
        break
      case 'williams':
        vars.push(`double williams_${node.id}[];`)
        break
      case 'sar':
        vars.push(`double sar_${node.id}[];`)
        break
      case 'obv':
        vars.push(`double obv_${node.id}[];`)
        break
      case 'vwap':
        vars.push(`double vwap_${node.id}[];`)
        break
    }
  })
  
  return vars.join('\n')
}

function generateGlobalVariablesMQL5(indicators: Node[]): string {
  const vars: string[] = []
  
  indicators.forEach(node => {
    const nodeType = node.id.split('_')[0]
    switch (nodeType) {
      case 'sma':
      case 'ema':
      case 'wma':
        vars.push(`int handle_${node.id};`)
        vars.push(`double ${nodeType}_${node.id}[];`)
        break
      case 'rsi':
        vars.push(`int handle_rsi_${node.id};`)
        vars.push(`double rsi_${node.id}[];`)
        break
      case 'macd':
        vars.push(`int handle_macd_${node.id};`)
        vars.push(`double macd_main_${node.id}[], macd_signal_${node.id}[];`)
        break
      case 'bb':
        vars.push(`int handle_bb_${node.id};`)
        vars.push(`double bb_upper_${node.id}[], bb_middle_${node.id}[], bb_lower_${node.id}[];`)
        break
      case 'atr':
        vars.push(`int handle_atr_${node.id};`)
        vars.push(`double atr_${node.id}[];`)
        break
    }
  })
  
  return vars.join('\n')
}

function generateIndicatorCalculations(indicators: Node[]): string {
  const calcs: string[] = []
  
  indicators.forEach(node => {
    const data = node.data as any
    const params = data.parameters || {}
    const indicatorType = data.indicatorType || node.id.split('_')[0]
    
    switch (indicatorType) {
      case 'sma':
        calcs.push(`   double sma_${node.id} = iMA(NULL, 0, MA_Period_${node.id}, 0, MODE_SMA, PRICE_CLOSE, 0);`)
        break
      case 'ema':
        calcs.push(`   double ema_${node.id} = iMA(NULL, 0, MA_Period_${node.id}, 0, MODE_EMA, PRICE_CLOSE, 0);`)
        break
      case 'wma':
        calcs.push(`   double wma_${node.id} = iMA(NULL, 0, MA_Period_${node.id}, 0, MODE_LWMA, PRICE_CLOSE, 0);`)
        break
      case 'rsi':
        calcs.push(`   double rsi_${node.id} = iRSI(NULL, 0, RSI_Period_${node.id}, PRICE_CLOSE, 0);`)
        break
      case 'macd':
        calcs.push(`   double macd_main_${node.id} = iMACD(NULL, 0, MACD_Fast_${node.id}, MACD_Slow_${node.id}, MACD_Signal_${node.id}, PRICE_CLOSE, MODE_MAIN, 0);`)
        calcs.push(`   double macd_signal_${node.id} = iMACD(NULL, 0, MACD_Fast_${node.id}, MACD_Slow_${node.id}, MACD_Signal_${node.id}, PRICE_CLOSE, MODE_SIGNAL, 0);`)
        break
      case 'bb':
        calcs.push(`   double bb_upper_${node.id} = iBands(NULL, 0, BB_Period_${node.id}, BB_Deviation_${node.id}, 0, PRICE_CLOSE, MODE_UPPER, 0);`)
        calcs.push(`   double bb_middle_${node.id} = iBands(NULL, 0, BB_Period_${node.id}, BB_Deviation_${node.id}, 0, PRICE_CLOSE, MODE_MAIN, 0);`)
        calcs.push(`   double bb_lower_${node.id} = iBands(NULL, 0, BB_Period_${node.id}, BB_Deviation_${node.id}, 0, PRICE_CLOSE, MODE_LOWER, 0);`)
        break
      case 'atr':
        calcs.push(`   double atr_${node.id} = iATR(NULL, 0, ATR_Period_${node.id}, 0);`)
        break
      case 'stochastic':
        calcs.push(`   double stoch_main_${node.id} = iStochastic(NULL, 0, Stoch_K_Period_${node.id}, Stoch_D_Period_${node.id}, Stoch_Slowing_${node.id}, MODE_SMA, 0, MODE_MAIN, 0);`)
        calcs.push(`   double stoch_signal_${node.id} = iStochastic(NULL, 0, Stoch_K_Period_${node.id}, Stoch_D_Period_${node.id}, Stoch_Slowing_${node.id}, MODE_SMA, 0, MODE_SIGNAL, 0);`)
        break
      case 'cci':
        calcs.push(`   double cci_${node.id} = iCCI(NULL, 0, CCI_Period_${node.id}, PRICE_TYPICAL, 0);`)
        break
      case 'adx':
        calcs.push(`   double adx_${node.id} = iADX(NULL, 0, ADX_Period_${node.id}, PRICE_CLOSE, MODE_MAIN, 0);`)
        break
      case 'williams':
        calcs.push(`   double williams_${node.id} = iWPR(NULL, 0, Williams_Period_${node.id}, 0);`)
        break
      case 'sar':
        calcs.push(`   double sar_${node.id} = iSAR(NULL, 0, SAR_Step_${node.id}, SAR_Maximum_${node.id}, 0);`)
        break
      case 'obv':
        calcs.push(`   double obv_${node.id} = iOBV(NULL, 0, PRICE_CLOSE, 0);`)
        break
      case 'vwap':
        calcs.push(`   // VWAP calculation - custom implementation needed`)
        calcs.push(`   double vwap_${node.id} = Close[0]; // Placeholder`)
        break
    }
  })
  
  return calcs.join('\n')
}

function generateIndicatorCalculationsMQL5(indicators: Node[]): string {
  const calcs: string[] = []
  
  indicators.forEach(node => {
    const nodeType = node.id.split('_')[0]
    
    switch (nodeType) {
      case 'sma':
      case 'ema':
      case 'wma':
        calcs.push(`   CopyBuffer(handle_${node.id}, 0, 0, 1, ${nodeType}_${node.id});`)
        break
      case 'rsi':
        calcs.push(`   CopyBuffer(handle_rsi_${node.id}, 0, 0, 1, rsi_${node.id});`)
        break
      case 'macd':
        calcs.push(`   CopyBuffer(handle_macd_${node.id}, 0, 0, 1, macd_main_${node.id});`)
        calcs.push(`   CopyBuffer(handle_macd_${node.id}, 1, 0, 1, macd_signal_${node.id});`)
        break
      case 'bb':
        calcs.push(`   CopyBuffer(handle_bb_${node.id}, 0, 0, 1, bb_upper_${node.id});`)
        calcs.push(`   CopyBuffer(handle_bb_${node.id}, 1, 0, 1, bb_middle_${node.id});`)
        calcs.push(`   CopyBuffer(handle_bb_${node.id}, 2, 0, 1, bb_lower_${node.id});`)
        break
      case 'atr':
        calcs.push(`   CopyBuffer(handle_atr_${node.id}, 0, 0, 1, atr_${node.id});`)
        break
    }
  })
  
  return calcs.join('\n')
}

function generateConditionChecks(conditions: Node[], edges: Edge[], nodes: Node[]): string {
  const checks: string[] = []
  
  checks.push('   // Condition Checks')
  checks.push('   bool buyCondition = false;')
  checks.push('   bool sellCondition = false;')
  checks.push('')
  
  const buyActions = nodes.filter(n => n.type === 'action' && (n.data as any).action === 'buy')
  const sellActions = nodes.filter(n => n.type === 'action' && (n.data as any).action === 'sell')
  
  if (buyActions.length > 0) {
    checks.push('   // Buy Conditions')
    buyActions.forEach(action => {
      const conditionChain = buildConditionChain(action, edges, nodes)
      if (conditionChain) {
        checks.push(`   buyCondition = ${conditionChain};`)
      }
    })
    checks.push('')
  }
  
  if (sellActions.length > 0) {
    checks.push('   // Sell Conditions')
    sellActions.forEach(action => {
      const conditionChain = buildConditionChain(action, edges, nodes)
      if (conditionChain) {
        checks.push(`   sellCondition = ${conditionChain};`)
      }
    })
  }
  
  return checks.join('\n')
}

function buildConditionChain(targetNode: Node, edges: Edge[], nodes: Node[]): string {
  const incomingEdges = edges.filter(e => e.target === targetNode.id)
  
  if (incomingEdges.length === 0) {
    return 'true'
  }
  
  const conditions: string[] = []
  
  incomingEdges.forEach(edge => {
    const sourceNode = nodes.find(n => n.id === edge.source)
    if (!sourceNode) return
    
    const data = sourceNode.data as any
    
    if (sourceNode.type === 'condition') {
      const operator = data.operator || 'gt'
      const threshold = data.parameters?.threshold || 50
      
      const indicatorEdges = edges.filter(e => e.target === sourceNode.id)
      if (indicatorEdges.length > 0) {
        const indicatorNode = nodes.find(n => n.id === indicatorEdges[0].source)
        if (indicatorNode) {
          const indicatorData = indicatorNode.data as any
          const indicatorType = indicatorData.indicatorType || indicatorNode.id.split('_')[0]
          const indicatorVar = `${indicatorType}_${indicatorNode.id}`
          
          let condition = ''
          switch (operator) {
            case 'gt':
              condition = `(${indicatorVar} > ${threshold})`
              break
            case 'lt':
              condition = `(${indicatorVar} < ${threshold})`
              break
            case 'gte':
              condition = `(${indicatorVar} >= ${threshold})`
              break
            case 'lte':
              condition = `(${indicatorVar} <= ${threshold})`
              break
            case 'eq':
              condition = `(${indicatorVar} == ${threshold})`
              break
            case 'cross_above':
              condition = `(${indicatorVar} > ${threshold} && iMA(NULL, 0, MA_Period_${indicatorNode.id}, 0, MODE_SMA, PRICE_CLOSE, 1) <= ${threshold})`
              break
            case 'cross_below':
              condition = `(${indicatorVar} < ${threshold} && iMA(NULL, 0, MA_Period_${indicatorNode.id}, 0, MODE_SMA, PRICE_CLOSE, 1) >= ${threshold})`
              break
            default:
              condition = `(${indicatorVar} > ${threshold})`
          }
          
          conditions.push(condition)
        }
      }
    } else if (sourceNode.type === 'logic') {
      const logicType = data.label || 'AND'
      const subCondition = buildConditionChain(sourceNode, edges, nodes)
      if (subCondition) {
        conditions.push(subCondition)
      }
    }
  })
  
  if (conditions.length === 0) {
    return 'true'
  }
  
  return conditions.length === 1 ? conditions[0] : `(${conditions.join(' && ')})`
}

function generateConditionChecksMQL5(conditions: Node[], edges: Edge[], nodes: Node[]): string {
  return generateConditionChecks(conditions, edges, nodes)
}

function generateTradeLogic(actions: Node[], edges: Edge[], nodes: Node[]): string {
  const logic: string[] = []
  
  logic.push('')
  logic.push('   // Trade Execution')
  logic.push('   if(buyCondition && OrdersTotal() == 0)')
  logic.push('   {')
  logic.push('      double sl = Ask - StopLoss_Pips * Point * 10;')
  logic.push('      double tp = Ask + TakeProfit_Pips * Point * 10;')
  logic.push('      int ticket = OrderSend(Symbol(), OP_BUY, LotSize, Ask, Slippage, sl, tp, "ForexFlow Buy", MagicNumber, 0, clrGreen);')
  logic.push('      if(ticket > 0)')
  logic.push('         Print("Buy order opened successfully");')
  logic.push('   }')
  logic.push('')
  logic.push('   if(sellCondition && OrdersTotal() == 0)')
  logic.push('   {')
  logic.push('      double sl = Bid + StopLoss_Pips * Point * 10;')
  logic.push('      double tp = Bid - TakeProfit_Pips * Point * 10;')
  logic.push('      int ticket = OrderSend(Symbol(), OP_SELL, LotSize, Bid, Slippage, sl, tp, "ForexFlow Sell", MagicNumber, 0, clrRed);')
  logic.push('      if(ticket > 0)')
  logic.push('         Print("Sell order opened successfully");')
  logic.push('   }')
  
  return logic.join('\n')
}

function generateTradeLogicMQL5(actions: Node[], edges: Edge[], nodes: Node[]): string {
  const logic: string[] = []
  
  logic.push('')
  logic.push('   // Trade Execution')
  logic.push('   if(buyCondition && PositionsTotal() == 0)')
  logic.push('   {')
  logic.push('      double sl = SymbolInfoDouble(_Symbol, SYMBOL_ASK) - StopLoss_Pips * _Point * 10;')
  logic.push('      double tp = SymbolInfoDouble(_Symbol, SYMBOL_ASK) + TakeProfit_Pips * _Point * 10;')
  logic.push('      if(trade.Buy(LotSize, _Symbol, 0, sl, tp, "ForexFlow Buy"))')
  logic.push('         Print("Buy order opened successfully");')
  logic.push('   }')
  logic.push('')
  logic.push('   if(sellCondition && PositionsTotal() == 0)')
  logic.push('   {')
  logic.push('      double sl = SymbolInfoDouble(_Symbol, SYMBOL_BID) + StopLoss_Pips * _Point * 10;')
  logic.push('      double tp = SymbolInfoDouble(_Symbol, SYMBOL_BID) - TakeProfit_Pips * _Point * 10;')
  logic.push('      if(trade.Sell(LotSize, _Symbol, 0, sl, tp, "ForexFlow Sell"))')
  logic.push('         Print("Sell order opened successfully");')
  logic.push('   }')
  
  return logic.join('\n')
}

function generateHelperFunctions(): string {
  return `//+------------------------------------------------------------------+
//| Helper Functions                                                 |
//+------------------------------------------------------------------+
bool IsNewBar()
{
   static datetime lastBar = 0;
   datetime currentBar = iTime(NULL, 0, 0);
   
   if(lastBar != currentBar)
   {
      lastBar = currentBar;
      return true;
   }
   return false;
}

int CountOrders(int orderType)
{
   int count = 0;
   for(int i = OrdersTotal() - 1; i >= 0; i--)
   {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
      {
         if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber)
         {
            if(orderType == -1 || OrderType() == orderType)
               count++;
         }
      }
   }
   return count;
}`
}

function generateHelperFunctionsMQL5(): string {
  return `//+------------------------------------------------------------------+
//| Helper Functions                                                 |
//+------------------------------------------------------------------+
bool IsNewBar()
{
   static datetime lastBar = 0;
   datetime currentBar = iTime(_Symbol, PERIOD_CURRENT, 0);
   
   if(lastBar != currentBar)
   {
      lastBar = currentBar;
      return true;
   }
   return false;
}

int CountPositions(ENUM_POSITION_TYPE posType = -1)
{
   int count = 0;
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      if(PositionSelectByTicket(PositionGetTicket(i)))
      {
         if(PositionGetString(POSITION_SYMBOL) == _Symbol && 
            PositionGetInteger(POSITION_MAGIC) == MagicNumber)
         {
            if(posType == -1 || PositionGetInteger(POSITION_TYPE) == posType)
               count++;
         }
      }
   }
   return count;
}`
}
